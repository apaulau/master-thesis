} else {
crv <- computeCV(data, variogram$var_model, observations, nfold=observations)
estimation <- compStat(crv)[["Корреляция"]]
}
return(residual)
}
classicalResult <- sapply(cutoffs, FUN=function(cutoff) computePredictionEstimation(data=data, trend=trend, x=x, cressie=FALSE, cutoff=cutoff, observations=observations))
robustResult <- sapply(cutoffs, FUN=function(cutoff) computePredictionEstimation(data=data, trend=trend, x=x, cressie=TRUE, cutoff=cutoff, observations=observations))
if (nchar(filename)) {
plot.check <- DrawParameterComparison(cutoffs, classicalResult, robustResult)
ggsave(plot=plot.check, file=filename, width=7, height=3.3)
}
list(classical=which.min(classicalResult), robust=which.min(robustResult))
}
ComparePredictionParameters <- function(data, trend, x, filename="", observations, nrows, adapt=TRUE) {
cutoffs <- c(1:observations)
computePredictionEstimation <- function(data, trend, cressie, x, cutoff, observations) {
variogram <- ComputeVariogram(data, x=x, cressie=cressie, cutoff=cutoff, observations=observations)
if (adapt) {
kriging <- PredictWithKriging(data, x=x, observations=observations, variogram_model=variogram$var_model, nrows=nrows)
residual <- ComputeKrigingResiduals(src$temperature, trend, kriging, observations, nrows)
estimation <- MSE(residual)
} else {
crv <- computeCV(data, variogram$var_model, observations, nfold=observations)
estimation <- compStat(crv)[["Корреляция"]]
}
return(residual)
}
classicalResult <- sapply(cutoffs, FUN=function(cutoff) computePredictionEstimation(data=data, trend=trend, x=x, cressie=FALSE, cutoff=cutoff, observations=observations))
robustResult <- sapply(cutoffs, FUN=function(cutoff) computePredictionEstimation(data=data, trend=trend, x=x, cressie=TRUE, cutoff=cutoff, observations=observations))
if (nchar(filename)) {
plot.check <- DrawParameterComparison(cutoffs, classicalResult, robustResult, adapt)
ggsave(plot=plot.check, file=filename, width=7, height=3.3)
}
list(classical=which.min(classicalResult), robust=which.min(robustResult))
}
DrawParameterComparison <- function(cutoffs, classical, robust, adapt) {
ggplot() +
geom_line(data=data.frame("X"=cutoffs, "Y"=classical), aes(x=X, y=Y, linetype="Матерона")) +
geom_line(data=data.frame("X"=cutoffs, "Y"=robust), aes(x=X, y=Y, linetype="Кресси-Хокинса")) +
scale_linetype_manual(name="Lines", values=c("Матерона"="dashed", "Кресси-Хокинса"="dotdash")) +
scale_x_continuous(breaks=cutoffs) +
xlab("Максимальное расстояние") + ylab(ifelse(adapt, "MSE", "Корреляция")) +
theme(axis.text.x = element_text(angle=90, hjust=1))
}
adapt.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-mse-cutoff.png", observations=kObservationNum, nrows=nrows)
adapt.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-mse-cutoff.png", observations=kObservationNum, nrows=nrows)
debugSource('~/study/bachelors-thesis/R/lib/kriging.R')
adapt.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-mse-cutoff.png", observations=kObservationNum, nrows=nrows)
cutoffs
classicalResult
debugSource('~/study/bachelors-thesis/R/lib/kriging.R')
adapt.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-mse-cutoff.png", observations=kObservationNum, nrows=nrows)
kriging
src$temperature
trend
residual
MSE(residual)
debugSource('~/study/bachelors-thesis/R/lib/kriging.R')
adapt.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-mse-cutoff.png", observations=kObservationNum, nrows=nrows)
cv.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-corr-cutoff.png", observations=kObservationNum, nrows=nrows)
cv.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-corr-cutoff.png", observations=kObservationNum, nrows=nrows, adapt=FALSE)
cv.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-corr-cutoff.png", observations=kObservationNum, nrows=nrows, adapt=FALSE)
crv
compStat(crv)
source('~/study/bachelors-thesis/R/lib/kriging.R')
cv.cutoff <- ComparePredictionParameters(sample.residuals, trend, ConvertYearsToNum(sample$year), filename="figures/variogram/auto-corr-cutoff.png", observations=kObservationNum, nrows=nrows, adapt=FALSE)
shiny::runApp('R/shiny')
auto.rob.adapt <- ComputeVariogram(data=sample.residuals, x=sample$year, name="auto-rob-5", cressie=TRUE, cutoff=5)
auto.rob.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=auto.rob.adapt, cutoff=5, name="auto-rob-5", caption="Прогноз (волновая модель)")
auto.class.adapt <- ComputeVariogram(data=sample.residuals, x=sample$year, name="auto-class-18", cressie=FALSE, cutoff=18)
auto.class.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=auto.class.adapt, cutoff=18, name="auto-class-18", caption="Прогноз (периодическая модель)")
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
trend <- sapply(X=ConvertYearsToNum(src$year[(kObservationNum + 1):nrows]), FUN=linear, a=sample.fit$coefficients[[2]], b=sample.fit$coefficients[[1]])
sample.residuals.prediction.trend <- data.frame("Год"=src$year[(kObservationNum + 1):nrows],
"Актуальное"=src$temperature[(kObservationNum + 1):nrows],
"Прогнозное"=trend,
"Ошибка"=src$temperature[(kObservationNum + 1):nrows] - trend)
print(xtable(sample.residuals.prediction.trend, caption="Сравнение прогнозных значений (тренда)", label="table:prediction_trend", digits=c(0, 0, 2, 2, 2)),
file="out/residual/prediction-trend.tex")
shiny::runApp('R/shiny')
## Dependencies
library(ggplot2)  # eye-candy graphs
library(xtable)   # convert data to latex tables
library(outliers) # tests for outliers
library(tseries)  # adf test used
library(nortest)  # tests for normality
library(sp)       # spatial data
library(gstat)    # geostatistics
library(reshape2) # will see
lin.fit.adapt <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Lin", name="lin-fit-adapt", psill=2, range=6, nugget=0.3, fit=FALSE)
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
shiny::runApp('R/shiny')
lin.fit.adapt <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Lin", name="lin-fit-adapt", psill=2, range=6.2, nugget=0.3, fit=FALSE)
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
lin.fit.cv <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Lin", name="lin-fit-cv", psill=4, range=4, nugget=0, fit=FALSE)
lin.fit.adapt <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Lin", name="lin-fit-adapt", psill=4, range=2, nugget=0, fit=FALSE)
lin.fit.cv.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.cv, cutoff=cutoff, name="lin-fit-cv", caption="Прогноз (линейная модель с порогом)")
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
sph.fit.adapt <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Sph", name="sph-fit-adapt", psill=4, range=6.9, nugget=0.9, fit=FALSE)
sph.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=sph.fit.adapt, cutoff=cutoff, name="sph-fit-adapt", caption="Адаптивный прогноз (сферическая модель)")
debugSource('~/study/bachelors-thesis/R/lib/draw.R')
lin.fit.adapt <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Lin", name="lin-fit-adapt", psill=2, range=6.2, nugget=0.3, fit=FALSE)
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
actual
trend
kriging
debugSource('~/study/bachelors-thesis/R/lib/kriging.R')
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
temperature
years
trend
kriging
observations
prediction.trend
temperature[(observations - 1):observations]
nrows
trend[(observations + 1):nrows]
trend
trend
trend <- computeTrend(sample.fit)
trend
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
trend
lin.fit.adapt <- ComputeManualVariogram(data=sample.residuals, x=sample$year, cressie=FALSE, cutoff=20, model="Lin", name="lin-fit-adapt", psill=4, range=6.2, nugget=0.3, fit=FALSE)
lin.fit.adapt.prediction <- processPrediction(data=sample.residuals, year=sample$year, variogram=lin.fit.adapt, cutoff=cutoff, name="lin-fit-adapt", caption="Адаптивный прогноз (линейная модель с порогом)")
pr.mse <- MSE(src$temperature[(kObservationNum + 1):nrows] - trend)
trend <- sapply(X=ConvertYearsToNum(src$year[(kObservationNum + 1):nrows]), FUN=linear, a=sample.fit$coefficients[[2]], b=sample.fit$coefficients[[1]])
pr.mse <- MSE(src$temperature[(kObservationNum + 1):nrows] - trend)
pr.mse
shiny::runApp('R/shiny')
source("R/lib/plot.R")       # useful functions for more comfortable plotting
source("R/lib/dstats.R")     # descriptive statistics module
source("R/lib/misc.R")       # some useful global-use functions
source("R/lib/draw.R")       # helpers for drawing
source("R/lib/write.R")      # helpers for writing
source("R/lib/ntest.R")      # tests for normality
source("R/lib/regr.R")
source("R/lib/measures.R")
rm(list = ls(all = TRUE))
## Read the data / pattern: year;temperature
path.data <-
"data/batorino_july.csv" # this for future shiny support and may be choosing multiple data sources
nrows <- 38
src  <-
read.csv(
file = path.data, header = TRUE, sep = ";", nrows = nrows, colClasses =
c("numeric", "numeric"), stringsAsFactors = FALSE
)
## Global use constants
kDateBreaks <-
seq(min(src$year) - 5, max(src$year) + 5, by = 2) # date points for graphs
## For the reason of prediction estimation and comparison, let cut observations number by 3
kObservationNum <- length(src[, 1]) - 6
WriteCharacteristic(expression = kObservationNum, type = "original", name =
"n")
## Source data as basic time series plot: points connected with line
plot.source <-
DrawDataRepresentation(data = src, filename = "source.png", datebreaks =
kDateBreaks)
tmp <- src
colnames(tmp) <- c("Год", "Температура, ºС")
print(
xtable(
tmp, caption = "Исходные данные.", label = "table:source", digits = c(0, 0, 2), align =
"r|rc|"
),  table.placement = "H",
file = "out/original/data.tex", include.rownames = FALSE
)
## Form the data for research
sample <- src[0:kObservationNum,]
# Getting descriptive statistics for temperature in russian locale
sample.dstats <-
dstats.describe(sample$temperature, type = "original", locale = TRUE)
print(
xtable(sample.dstats, caption = "Описательные статистики для наблюдаемых температур.", label =
"table:dstats"),
file = "out/original/dstats.tex"
)
# Compute Sturges rule for output
WriteCharacteristic(
expression = nclass.Sturges(sample$temperature), type = "original", name =
"sturges"
)
## Basic histogram based on Sturges rule (by default) with pretty output (also by default)
plot.data.hist <-
DrawHistogram(data = sample, filename = "original/histogram.png")
## Tests for normality
sample.shapiro <-
ntest.ShapiroWilk(data = sample$temperature, type = "original", name =
"shapiro")
sample.pearson <-
ntest.PearsonChi2(data = sample$temperature, type = "original", name =
"pearson")
sample.ks      <-
ntest.KolmogorovSmirnov(data = sample$temperature, type = "original", name =
"ks")
## Normal Quantile-Quantile plot // TODO: check when it appears in text
plot.data.qq <-
DrawQuantileQuantile(data = sample$temperature, filename = "original/quantile.png")
## Scatter plot with regression line
plot.data.scatter <-
DrawScatterPlot(sample, filename = "original/scatterplot.png", kDateBreaks);
## Grubbs test for outliers
sample.grubbs <- grubbs.test(sample$temperature)
WriteTest(sample.grubbs$statistic[1], sample.grubbs$p.value, type = "original", name =
"grubbs")
## Compute correlation for output
sample.correlation <- cor(x = sample$year, y = sample$temperature)
WriteCharacteristic(sample.correlation, type = "original", name = "correlation")
WriteTest(
sample.correlation * sqrt(kObservationNum - 2) / (1 - sample.correlation ^
2), 0, qt(1 - 0.05, kObservationNum - 2), type = "original", name = "student"
)
## Pearson's product-moment correlation test. Use time for y as numerical
sample.ctest <-
cor.test(sample$temperature, c(1:kObservationNum), method = "pearson")
WriteTest(
sample.ctest$statistic, sample.ctest$p.value, sample.ctest$parameter[[1]], type =
"original", name = "correlation"
)
## Fitting linear model for researching data. It also compute residuals based on subtracted regression
sample.fit <- lm(sample$temperature ~ c(1:kObservationNum))
linear <- function(x, a, b)
a * x + b
pr.trend <-
sapply(
X = ConvertYearsToNum(src$year[(kObservationNum + 1):nrows]), FUN = linear, a =
sample.fit$coefficients[[2]], b = sample.fit$coefficients[[1]]
)
sample.residuals.prediction.trend <-
data.frame(
"Год" = src$year[(kObservationNum + 1):nrows],
"Актуальное" = src$temperature[(kObservationNum + 1):nrows],
"Прогнозное" = pr.trend,
"Ошибка" = src$temperature[(kObservationNum + 1):nrows] - pr.trend
)
pr.mse <-
MSE(src$temperature[(kObservationNum + 1):nrows] - pr.trend)
colnames(sample.residuals.prediction.trend) <-
c("", "$X(t)$", "$y(t)$", "$ X(t) - y(t) $")
print(
xtable(
sample.residuals.prediction.trend, caption = "Сравнение прогнозных значений (модель $ y(t) $)", label =
"table:prediction_trend", digits = c(0, 0, 3, 3, 3), align = "rr|ccc"
),
file = "out/residual/prediction-trend.tex", sanitize.text.function = function(x) {
x
}, include.rownames = FALSE
)
## Time series (which is by default is research data) with trend line based on linear module estimate (lm)
plot.data.ts <-
DrawTimeSeries(data = sample, filename = "original/time-series.png", datebreaks =
kDateBreaks)
## Next step is research residuals computed few lines above
sample.residuals <-
data.frame("year" = sample$year, "temperature" = sample.fit$residuals)
tmp <- sample.residuals
colnames(tmp) <- c("Год", "Температура, ºС")
print(
xtable(
tmp, caption = "Временной ряд остатков", label = "table:residuals", digits =
c(0, 0, 2), align = "r|rc|"
),  table.placement = "H",
file = "out/residual/data.tex", include.rownames = FALSE
)
sign <- regr.significance(sample$temperature, write = TRUE)
adeq <- regr.adequacy(sample$temperature, write = TRUE)
## Residuals time series (data have gotten on computing step: fitting linear model)
plot.residuals.ts <-
DrawTimeSeries(data = sample.residuals, filename = "residual/time-series.png", datebreaks =
kDateBreaks)
## Descriptive statistics for residuals
sample.residuals.dstats <-
dstats.describe(sample.residuals$temperature, type = "residual", locale =
TRUE)
print(
xtable(
sample.residuals.dstats, caption = "Описательные статистики остатков", label =
"table:residuals_dstats"
),
file = "out/residual/dstats.tex"
)
## Basic histogram for residuals / seems like the same as for non-residuals
plot.residuals.hist <-
DrawHistogram(data = sample.residuals, filename = "residual/histogram.png")
## Tests for normality
sample.shapiro <-
ntest.ShapiroWilk(data = sample.residuals$temperature, type = "residual", name =
"shapiro")
sample.pearson <-
ntest.PearsonChi2(data = sample.residuals$temperature, type = "residual", name =
"pearson")
sample.ks      <-
ntest.KolmogorovSmirnov(data = sample.residuals$temperature, type = "residual", name =
"ks")
## Normal Quantile-Quantile plot for residuals
plot.residuals.qq <-
DrawQuantileQuantile(data = sample.residuals$temperature, filename = "residual/quantile.png")
## Auto Correlation Function plot
plot.residuals.acf <-
DrawAutoCorrelationFunction(data = sample$temperature, filename = "residual/acf.png")
## Box-Ljung and adf tests (some kind of stationarity and independence tests) // TODO: need to know exactly in theory what it is
sample.residuals.box <-
Box.test(sample.residuals$temperature, type = "Ljung-Box")
WriteTest(
sample.residuals.box$statistic, sample.residuals.box$p.value, sample.residuals.box$parameter[[1]], type =
"residual", name = "ljung-box"
)
sample.residuals.adf <- adf.test(sample.residuals$temperature)
WriteTest(
sample.residuals.adf$statistic, sample.residuals.adf$p.value, type = "residual", name =
"stationarity"
)
## Dependencies
library(ggplot2)  # eye-candy graphs
library(xtable)   # convert data to latex tables
library(outliers) # tests for outliers
library(tseries)  # adf test used
library(nortest)  # tests for normality
library(sp)       # spatial data
library(gstat)    # geostatistics
library(reshape2) # will see
## Import local modules
source("R/lib/plot.R")       # useful functions for more comfortable plotting
source("R/lib/dstats.R")     # descriptive statistics module
source("R/lib/misc.R")       # some useful global-use functions
source("R/lib/draw.R")       # helpers for drawing
source("R/lib/write.R")      # helpers for writing
source("R/lib/ntest.R")      # tests for normality
source("R/lib/regr.R")
source("R/lib/measures.R")
path.data <-
"data/batorino_july.csv" # this for future shiny support and may be choosing multiple data sources
nrows <- 38
src  <-
read.csv(
file = path.data, header = TRUE, sep = ";", nrows = nrows, colClasses =
c("numeric", "numeric"), stringsAsFactors = FALSE
)
## Global use constants
kDateBreaks <-
seq(min(src$year) - 5, max(src$year) + 5, by = 2) # date points for graphs
## For the reason of prediction estimation and comparison, let cut observations number by 3
kObservationNum <- length(src[, 1]) - 6
WriteCharacteristic(expression = kObservationNum, type = "original", name =
"n")
## Source data as basic time series plot: points connected with line
plot.source <-
DrawDataRepresentation(data = src, filename = "source.png", datebreaks =
kDateBreaks)
tmp <- src
colnames(tmp) <- c("Год", "Температура, ºС")
print(
xtable(
tmp, caption = "Исходные данные.", label = "table:source", digits = c(0, 0, 2), align =
"r|rc|"
),  table.placement = "H",
file = "out/original/data.tex", include.rownames = FALSE
)
## Form the data for research
sample <- src[0:kObservationNum,]
# Getting descriptive statistics for temperature in russian locale
sample.dstats <-
dstats.describe(sample$temperature, type = "original", locale = TRUE)
print(
xtable(sample.dstats, caption = "Описательные статистики для наблюдаемых температур.", label =
"table:dstats"),
file = "out/original/dstats.tex"
)
# Compute Sturges rule for output
WriteCharacteristic(
expression = nclass.Sturges(sample$temperature), type = "original", name =
"sturges"
)
## Basic histogram based on Sturges rule (by default) with pretty output (also by default)
plot.data.hist <-
DrawHistogram(data = sample, filename = "original/histogram.png")
## Tests for normality
sample.shapiro <-
ntest.ShapiroWilk(data = sample$temperature, type = "original", name =
"shapiro")
sample.pearson <-
ntest.PearsonChi2(data = sample$temperature, type = "original", name =
"pearson")
sample.ks      <-
ntest.KolmogorovSmirnov(data = sample$temperature, type = "original", name =
"ks")
## Normal Quantile-Quantile plot // TODO: check when it appears in text
plot.data.qq <-
DrawQuantileQuantile(data = sample$temperature, filename = "original/quantile.png")
## Scatter plot with regression line
plot.data.scatter <-
DrawScatterPlot(sample, filename = "original/scatterplot.png", kDateBreaks);
## Grubbs test for outliers
sample.grubbs <- grubbs.test(sample$temperature)
WriteTest(sample.grubbs$statistic[1], sample.grubbs$p.value, type = "original", name =
"grubbs")
## Compute correlation for output
sample.correlation <- cor(x = sample$year, y = sample$temperature)
WriteCharacteristic(sample.correlation, type = "original", name = "correlation")
WriteTest(
sample.correlation * sqrt(kObservationNum - 2) / (1 - sample.correlation ^
2), 0, qt(1 - 0.05, kObservationNum - 2), type = "original", name = "student"
)
## Pearson's product-moment correlation test. Use time for y as numerical
sample.ctest <-
cor.test(sample$temperature, c(1:kObservationNum), method = "pearson")
WriteTest(
sample.ctest$statistic, sample.ctest$p.value, sample.ctest$parameter[[1]], type =
"original", name = "correlation"
)
## Fitting linear model for researching data. It also compute residuals based on subtracted regression
sample.fit <- lm(sample$temperature ~ c(1:kObservationNum))
linear <- function(x, a, b)
a * x + b
pr.trend <-
sapply(
X = ConvertYearsToNum(src$year[(kObservationNum + 1):nrows]), FUN = linear, a =
sample.fit$coefficients[[2]], b = sample.fit$coefficients[[1]]
)
sample.residuals.prediction.trend <-
data.frame(
"Год" = src$year[(kObservationNum + 1):nrows],
"Актуальное" = src$temperature[(kObservationNum + 1):nrows],
"Прогнозное" = pr.trend,
"Ошибка" = src$temperature[(kObservationNum + 1):nrows] - pr.trend
)
pr.mse <-
MSE(src$temperature[(kObservationNum + 1):nrows] - pr.trend)
colnames(sample.residuals.prediction.trend) <-
c("", "$X(t)$", "$y(t)$", "$ X(t) - y(t) $")
print(
xtable(
sample.residuals.prediction.trend, caption = "Сравнение прогнозных значений (модель $ y(t) $)", label =
"table:prediction_trend", digits = c(0, 0, 3, 3, 3), align = "rr|ccc"
),
file = "out/residual/prediction-trend.tex", sanitize.text.function = function(x) {
x
}, include.rownames = FALSE
)
## Time series (which is by default is research data) with trend line based on linear module estimate (lm)
plot.data.ts <-
DrawTimeSeries(data = sample, filename = "original/time-series.png", datebreaks =
kDateBreaks)
## Next step is research residuals computed few lines above
sample.residuals <-
data.frame("year" = sample$year, "temperature" = sample.fit$residuals)
tmp <- sample.residuals
colnames(tmp) <- c("Год", "Температура, ºС")
print(
xtable(
tmp, caption = "Временной ряд остатков", label = "table:residuals", digits =
c(0, 0, 2), align = "r|rc|"
),  table.placement = "H",
file = "out/residual/data.tex", include.rownames = FALSE
)
sign <- regr.significance(sample$temperature, write = TRUE)
adeq <- regr.adequacy(sample$temperature, write = TRUE)
## Residuals time series (data have gotten on computing step: fitting linear model)
plot.residuals.ts <-
DrawTimeSeries(data = sample.residuals, filename = "residual/time-series.png", datebreaks =
kDateBreaks)
## Descriptive statistics for residuals
sample.residuals.dstats <-
dstats.describe(sample.residuals$temperature, type = "residual", locale =
TRUE)
print(
xtable(
sample.residuals.dstats, caption = "Описательные статистики остатков", label =
"table:residuals_dstats"
),
file = "out/residual/dstats.tex"
)
## Basic histogram for residuals / seems like the same as for non-residuals
plot.residuals.hist <-
DrawHistogram(data = sample.residuals, filename = "residual/histogram.png")
## Tests for normality
sample.shapiro <-
ntest.ShapiroWilk(data = sample.residuals$temperature, type = "residual", name =
"shapiro")
sample.pearson <-
ntest.PearsonChi2(data = sample.residuals$temperature, type = "residual", name =
"pearson")
sample.ks      <-
ntest.KolmogorovSmirnov(data = sample.residuals$temperature, type = "residual", name =
"ks")
## Normal Quantile-Quantile plot for residuals
plot.residuals.qq <-
DrawQuantileQuantile(data = sample.residuals$temperature, filename = "residual/quantile.png")
## Auto Correlation Function plot
plot.residuals.acf <-
DrawAutoCorrelationFunction(data = sample$temperature, filename = "residual/acf.png")
## Box-Ljung and adf tests (some kind of stationarity and independence tests) // TODO: need to know exactly in theory what it is
sample.residuals.box <-
Box.test(sample.residuals$temperature, type = "Ljung-Box")
WriteTest(
sample.residuals.box$statistic, sample.residuals.box$p.value, sample.residuals.box$parameter[[1]], type =
"residual", name = "ljung-box"
)
sample.residuals.adf <- adf.test(sample.residuals$temperature)
WriteTest(
sample.residuals.adf$statistic, sample.residuals.adf$p.value, type = "residual", name =
"stationarity"
)
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
