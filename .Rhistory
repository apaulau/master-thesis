print(xtable(research.residuals.dstats, caption="Описательные статистики для остатков.", label="table:residuals_dstats"),
file="out/residuals_dstats.tex")
## Basic histogram for residuals / seems like the same as for non-residuals
plot.residuals.hist <- DrawHistogram(data=research.residuals, filename="residual/histogram.png", datebreaks=kDateBreaks)
## Tests for normality
research.data.shapiro <- ntest.ShapiroWilk(data=research.residuals$temperature, filename="out/residual/shapiro-test.tex")
research.data.pearson <- ntest.PearsonChi2(data=research.residuals$temperature, filename="out/residual/pearson-test.tex")
research.data.ks      <- ntest.KolmogorovSmirnov(data=research.residuals$temperature, filename="out/residual/ks-test.tex")
## Normal Quantile-Quantile plot for residuals
plot.residuals.qq <- DrawQuantileQunatile(data=research.residuals$temperature, filename="residual/qunatile.png")
## Auto Correlation Function plot // TODO: check the style
plot.residuals.acf <- DrawAutoCorrelationFunction(data=research.data$temperature, filename="residual/acf.png")
## Box-Ljung and adf tests (some kind of stationarity and independence tests) // TODO: need to know exactly in theory what it is
research.residuals.box <- Box.test(research.residuals$temperature, type="Ljung-Box")
to.file(research.residuals.box, "out/residual/ljung-test.tex")
research.residuals.adf <- adf.test(research.residuals$temperature)
to.file(research.residuals.adf, "out/residual/stationarity-test.tex")
install.packages('shiny')
library(shiny)
runExample("01_hello")
runApp("shiny")
runApp("R/shiny")
runApp("R/shiny")
runApp("R/shiny", display.mode = "showcase")
titlePanel("Shiny Application!"),
source('~/study/diploma/R/shiny/ui.R', echo=TRUE)
source('~/study/diploma/R/shiny/ui.R', echo=TRUE)
runApp("R/shiny", display.mode = "showcase")
runApp("R/shiny", display.mode = "showcase")
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
class(c(1,2))
src.data
src.data[c(3,35)]
src.data[c(3:35)]
src.data[3:35]
src.data[3:35,]
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
source("../lib/plot.R")       # useful functions for more comfortable plotting
shiny::runApp('R/shiny')
runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
instal.packages("ggvis")
install.packages("ggvis")
install.packages("dplyr")
library(ggvis)
library(dplyr)
packrat::restore(prompt = FALSE)
layer_points() + layer_line() + lay
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
src.data[1:2]
src.data[1:2,]
src.data[1:2,1]
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
format(1300)
format(1.300)
shiny::runApp('R/shiny')
?add_axis
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
?density
density(1:30)
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
?ifelse
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
nclass.Sturges(src.data)
src.data
nclass.scitt(src.data)
nclass.scott(src.data)
nclass.Sturges(src.data$temperature)
range(src.data$temperature)
8.3/7
nclass.scott(src.data$temperature)
8.3/4
shiny::runApp('R/shiny')
nclass.scott(src.data$temperature)
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
ggplot(src.data, aes(x=temperature), geom='blank') +
geom_histogram(aes(y=..density..), colour="darkgrey", fill="white", binwidth=binwidth, alpha=.6) +
stat_function(fun=dnorm, colour='red', arg=list(mean=mean(data$temperature), sd=sd(data$temperature))) +
labs(color="") + xlab("Температура, ºС") + ylab("Плотность")
ggplot(src.data, aes(x=temperature), geom='blank') +
geom_histogram(aes(y=..density..), colour="darkgrey", fill="white", binwidth=binwidth, alpha=.6) +
stat_function(fun=dnorm, colour='red', arg=list(mean=mean(src.data$temperature), sd=sd(src.data$temperature))) +
labs(color="") + xlab("Температура, ºС") + ylab("Плотность")
ggplot(src.data, aes(x=temperature), geom='blank') +
geom_histogram(aes(y=..density..), colour="darkgrey", fill="white", alpha=.6) +
stat_function(fun=dnorm, colour='red', arg=list(mean=mean(src.data$temperature), sd=sd(src.data$temperature))) +
labs(color="") + xlab("Температура, ºС") + ylab("Плотность")
ggplot(src.data, aes(x=temperature), geom='blank') +
geom_histogram(aes(y=..density..), colour="darkgrey", fill="white", alpha=.6) +
geom_density() +
labs(color="") + xlab("Температура, ºС") + ylab("Плотность")
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
shiny::runApp('R/shiny')
research.residuals.dstats <- dstats.describe(research.residuals$temperature, locale=TRUE)
print(xtable(research.residuals.dstats, caption="Описательные статистики для остатков.", label="table:residuals_dstats"),
file="out/residual/dstats.tex")
# Let's start from beginning.
# This file will be the master file of all diploma project's files (slaves).
# Content will be the same as for previous works (batorino analysis).
# Some thoughts for this investigation see in TODO.Rmd.
# Ideas for organizing further research see in ideas.Rmd
## Cleaning up the workspace
rm(list=ls(all=TRUE))
## Dependencies
library(ggplot2)  # eye-candy graphs
library(xtable)   # convert data to latex tables
library(outliers) # tests for outliers
library(tseries)  # adf test used
library(nortest)  # tests for normality
library(sp)       # spatial data
library(gstat)    # geostatistics
library(reshape2) # will see
## Import local modules
source("R/lib/plot.R")       # useful functions for more comfortable plotting
source("R/lib/print.R")      # functions for print some data to files
source("R/lib/dstats.R")     # descriptive statistics module
source("R/lib/misc.R")       # some useful global-use functions
source("R/lib/draw.R")       # helpers for drawing
source("R/lib/ntest.R")      # tests for normality
## Read the data / pattern: year;temperature
path.data <- "data/batorino_july.csv" # this for future shiny support and may be choosing multiple data sources
src.nrows <- 38
src.data  <- read.csv(file=path.data, header=TRUE, sep=";", nrows=src.nrows, colClasses=c("numeric", "numeric"), stringsAsFactors=FALSE)
## Global use constants
kDateBreaks <- seq(min(src.data$year) - 5, max(src.data$year) + 5, by=2) # date points for graphs
## For the reason of prediction estimation and comparison, let cut observations number by 3
kObservationNum <- length(src.data[, 1]) - 3
## Source data as basic time series plot: points connected with line
plot.source <- DrawDataRepresentation(data=src.data, filename="source.png", datebreaks=kDateBreaks)
print(xtable(src.data, caption="Исходные данные.", label="table:source"),  table.placement="H",
file="out/original/data.tex")
## Form the data for research
research.data <- src.data[0:kObservationNum, ]
# Getting descriptive statistics for temperature in russian locale
research.data.dstats <- dstats.describe(research.data$temperature, locale=TRUE)
print(xtable(research.data.dstats, caption="Описательные статистики для наблюдаемых температур.", label="table:dstats"),
file="out/original/dstats.tex")
## Basic histogram based on Sturges rule (by default) with pretty output (also by default)
plot.data.hist <- DrawHistogram(data=research.data, filename="original/histogram.png")
## Tests for normality
research.data.shapiro <- ntest.ShapiroWilk(data=research.data$temperature, filename="out/original/shapiro-test.tex")
research.data.pearson <- ntest.PearsonChi2(data=research.data$temperature, filename="out/original/pearson-test.tex")
research.data.ks      <- ntest.KolmogorovSmirnov(data=research.data$temperature, filename="out/original/ks-test.tex")
## Normal Quantile-Quantile plot // TODO: check when it appears in text
plot.data.qq <- DrawQuantileQuantile(data=research.data$temperature, filename="original/quantile.png")
## Scatter plot with regression line
plot.data.scatter <- DrawScatterPlot(research.data, filename="original/scatterplot.png", kDateBreaks);
## Grubbs test for outliers
research.data.grubbs <- grubbs.test(research.data$temperature)
to.file(research.data.grubbs, "out/original/grubbs-test.tex")
## Correlation matrix
research.data.cmatrix <- cor(cbind("Temperature"=research.data$temperature, "Date"=1:kObservationNum), method="pearson")
print(xtable(research.data.cmatrix, caption="Корреляционная матрица.", label="table:cmatrix"),
file="out/original/corr-matrix.tex")
## Pearson's product-moment correlation test. Use time for y as numerical
research.data.ctest <- cor.test(research.data$temperature, c(1:kObservationNum), method="pearson")
to.file(research.data.ctest, "out/original/corr-test.tex")
## Fitting linear model for researching data. It also compute residuals based on subtracted regression
research.data.fit <- lm(research.data$temperature ~ c(1:kObservationNum))
## Time series (which is by default is research data) with trend line based on linear module estimate (lm)
plot.data.ts <- DrawTimeSeries(data=research.data, filename="original/time-series.png", datebreaks=kDateBreaks)
## Next step is research residuals computed few lines above
research.residuals <- data.frame("year"=research.data$year, "temperature"=research.data.fit$residuals)
print(xtable(research.residuals, caption="Временной ряд остатков.", label="table:residuals"), table.placement="H",
file="out/residual/data.tex")
## Residuals time series (data have gotten on computing step: fitting linear model)
plot.residuals.ts <- DrawTimeSeries(data=research.residuals, filename="residual/time-series.png", datebreaks=kDateBreaks)
## Descriptive statistics for residuals
research.residuals.dstats <- dstats.describe(research.residuals$temperature, locale=TRUE)
print(xtable(research.residuals.dstats, caption="Описательные статистики для остатков.", label="table:residuals_dstats"),
file="out/residual/dstats.tex")
## Basic histogram for residuals / seems like the same as for non-residuals
plot.residuals.hist <- DrawHistogram(data=research.residuals, filename="residual/histogram.png")
## Tests for normality
research.data.shapiro <- ntest.ShapiroWilk(data=research.residuals$temperature, filename="out/residual/shapiro-test.tex")
research.data.pearson <- ntest.PearsonChi2(data=research.residuals$temperature, filename="out/residual/pearson-test.tex")
research.data.ks      <- ntest.KolmogorovSmirnov(data=research.residuals$temperature, filename="out/residual/ks-test.tex")
## Normal Quantile-Quantile plot for residuals
plot.residuals.qq <- DrawQuantileQuantile(data=research.residuals$temperature, filename="residual/quantile.png")
## Auto Correlation Function plot // TODO: check the style
plot.residuals.acf <- DrawAutoCorrelationFunction(data=research.data$temperature, filename="residual/acf.png")
## Box-Ljung and adf tests (some kind of stationarity and independence tests) // TODO: need to know exactly in theory what it is
research.residuals.box <- Box.test(research.residuals$temperature, type="Ljung-Box")
to.file(research.residuals.box, "out/residual/ljung-test.tex")
research.residuals.adf <- adf.test(research.residuals$temperature)
to.file(research.residuals.adf, "out/residual/stationarity-test.tex")
source("R/variogram.R")
### Just definition of mean standard error // TODO: find out exact formula and describe each parameter
MSE <- function (e, N=1) {
sum(sapply(X=e, FUN=function(x) x**2)) / N
}
ComparePredictionParameters <- function (data, residuals, temperature, trend, x, y=rep(1, kObservationNum), width=1) { ### todo: usage of argument in argument default
lens <- 1:kObservationNum
manualResult <- c()
classicalResult <- c()
robustResult <- c()
spdata <- data.frame(cbind("x"=x, "y"=y, data))
coordinates(spdata)=~x+y
i <- 1
for(l in lens) {
variogram.manual = manualVariogram(data, cutoff=l)
variogram.classical = autofitVariogram(data~1, spdata, cutoff=l, cressie=FALSE, width=width)
variogram.robust = autofitVariogram(data~1, spdata, cutoff=l, cressie=TRUE, width=width)
kriging.manual <- PredictWithKriging(residuals, x=x, variogram_model=variogram.manual$var_model)
kriging.classical <- PredictWithKriging(residuals, x=x, variogram_model=variogram.classical$var_model)
kriging.robust <- PredictWithKriging(residuals, x=x, variogram_model=variogram.robust$var_model)
res.manual <- CrossPrediction(temperature, trend, kriging.manual)
res.classical <- CrossPrediction(temperature, trend, kriging.classical)
res.robust <- CrossPrediction(temperature, trend, kriging.robust)
manualResult[i] <- MSE(e=res.manual)
classicalResult[i] <- MSE(e=res.classical)
robustResult[i] <- MSE(e=res.robust)
i = i + 1 ## todo: find out how to avoid this construction
}
plot.check <- ggplot() +
geom_line(data=data.frame("X"=lens, "Y"=manualResult), aes(x=X,y=Y)) +
geom_line(data=data.frame("X"=lens, "Y"=classicalResult), aes(x=X,y=Y), linetype="dashed") +
geom_line(data=data.frame("X"=lens, "Y"=robustResult), aes(x=X,y=Y), linetype="dotdash") +
scale_x_continuous(breaks=lens) +
scale_y_continuous(breaks=seq(min(manualResult, classicalResult, robustResult), max(manualResult, classicalResult, robustResult), .3))
ggsave(plot=plot.check, file="figures/check-dep.png", width=7, height=4)
}
ConvertYearsToNum
CompareVariogramParameters <- function (data, x, y=rep(1, kObservationNum), width) {
lens <- 1:kObservationNum
classicalResult <- c()
robustResult <- c()
spdata <- data.frame(cbind("x"=x, "y"=y, data))
coordinates(spdata) = ~x+y
i <- 1
for(l in lens) {
variogram.classical = autofitVariogram(data~1, spdata, cutoff=l, cressie=FALSE, width=width)
variogram.robust = autofitVariogram(data~1, spdata, cutoff=l, cressie=TRUE, width=width)
classicalResult[i] <- variogram.classical$sserr / l
robustResult[i] <- variogram.robust$sserr / l
i = i + 1
}
ggplot() +
geom_line(data=data.frame("X"=lens, "Y"=classicalResult), aes(x=X, y=Y, color="classic")) +
geom_line(data=data.frame("X"=lens, "Y"=robustResult), aes(x=X, y=Y, color="cressie")) +
scale_x_continuous(breaks=lens) +
scale_y_continuous(breaks=seq(1.04 * min(classicalResult, robustResult), 1.04 * max(classicalResult, robustResult), 1))
}
ComputeManualVariogram <- function (data, cutoff, file=FALSE, file_modeled="") {
# Make fake second coordinate
p <- data.frame("X"=c(1:kObservationNum), "Y"=rep(1,kObservationNum))
coordinates(p) <- ~ X + Y
experimental_variogram <- variogram(data~1, p, width=1, cutoff=cutoff)
model.variog <- vgm(model="Sph", range=3.9, nugget=3.4)
fit.variog <- fit.variogram(experimental_variogram, model.variog)
if (file) {
# Arrange the data for the ggplot2 plot
# add the semivariance values of v2 to v1
Fitted <- data.frame(dist = seq(0.01, max(experimental_variogram$dist), length = kObservationNum))
Fitted$gamma <- variogramLine(fit.variog, dist_vector = Fitted$dist)$gamma
#convert the dataframes to a long format
Empirical <- melt(experimental_variogram, id.vars = "dist", measure.vars = c("gamma"))
Modeled <- melt(Fitted, id.vars = "dist", measure.vars = c("gamma"))
plot.modeled <- ggplot(Empirical, aes(x = dist, y = value)) +  geom_point() +
geom_line(data = Modeled, color='blue') +
scale_y_continuous(expand=c(0,0),
breaks=seq(0, 1.04 * max(experimental_variogram$gamma), 1),
limits=c(min(0, 1.04 * min(experimental_variogram$gamma)), 1.04 * max(experimental_variogram$gamma))) +
scale_x_continuous(expand=c(0,0),
breaks=seq(0, 1.04 * max(experimental_variogram$dist), 1),
limits=c(0, 1.04 * max(experimental_variogram$dist))) +
xlab("Расстояние") + ylab("Значение")
ggsave(plot=plot.modeled, file=file_modeled, width=7, height=4)
}
print(xtable(data.frame("Модель"=fit.variog$model, "Порог"=fit.variog$psill, "Ранг"=fit.variog$range), caption="Модель вариограммы", label="table:manual_model"), table.placement="H",
file="out/manual_model.tex")
result = list(exp_var = experimental_variogram, var_model = fit.variog)
}
ComputeVariogram <- function (data, x, y=rep(1, kObservationNum), file_empirical="", file_modeled="", cressie, cutoff, width) {
spdata <- data.frame(cbind("x"=x, "y"=y, data))
coordinates(spdata) = ~x+y
variogram <- autofitVariogram(data~1, spdata, cutoff=cutoff, cressie=cressie, width=width)
if (nchar(file_empirical)) { ## here was another check: just <file>
# Arrange the data for the ggplot2 plot
# add the semivariance values of v2 to v1
Fitted <- data.frame(dist = seq(.01, max(variogram$exp_var$dist), length = kObservationNum))
Fitted$gamma <- variogramLine(variogram$var_model, dist_vector = Fitted$dist)$gamma
#convert the dataframes to a long format
Empirical <- melt(variogram$exp_var, id.vars="dist", measure.vars=c("gamma"))
Modeled <- melt(Fitted, id.vars="dist", measure.vars=c("gamma"))
plot.empirical <- ggplot(Empirical, aes(x=dist, y=value)) +  geom_point() +
scale_y_continuous(expand = c(0, 0), breaks=seq(0, 7, 1), limits=c(min(0, 1.04 * min(variogram$exp_var$gamma)), 1.04 * max(variogram$exp_var$gamma))) +
scale_x_continuous(expand = c(0, 0), breaks=seq(0, 1.04 * max(variogram$exp_var$dist), 2), limits=c(0, 1.04 * max(variogram$exp_var$dist))) +
xlab("Расстояние") + ylab("Значение")
ggsave(plot=plot.empirical, file=file_empirical, width=7, height=4)
}
if (nchar(file_modeled)) {
plot.modeled <- ggplot(Empirical, aes(x=dist, y=value)) +  geom_point() +
geom_line(data=Modeled, color='blue') +
scale_y_continuous(expand=c(0, 0),
breaks=seq(0, 1.04 * max(variogram$exp_var$gamma), 1),
limits=c(min(0, 1.04 * min(variogram$exp_var$gamma)), 1.04 * max(variogram$exp_var$gamma))) +
scale_x_continuous(expand=c(0, 0),
breaks=seq(0, 1.04 * max(variogram$exp_var$dist), 1),
limits=c(0, 1.04 * max(variogram$exp_var$dist))) +
xlab("Расстояние") + ylab("Значение")
ggsave(plot=plot.modeled, file=file_modeled, width=7, height=4)
}
#   plot(variogram)
variogram
}
PredictWithKriging <- function (data, x, y=rep(1, kObservationNum), variogram_model, future=0) {
src_data <- data.frame(cbind("x"=x, "y"=y, data))
coordinates(src_data)=~x+y
new_data <- data.frame("X"=c((kObservationNum + 1):(src.nrows + future)), "Y"=rep(1, src.nrows - kObservationNum))
coordinates(new_data) = ~X+Y
krige(data~1, src_data, new_data, model=variogram_model)
}
CrossPrediction <- function (temperature, trend, kriging, file_prediction="", future=0) {
prediction.trend <- data.frame("temperature"=c(temperature[(kObservationNum - 1):kObservationNum], trend[(kObservationNum + 1):src.nrows]),
"year"=GetPredictionYears(src.years, src.nrows, future))
prediction.kriging <- data.frame("temperature"=c(temperature[(kObservationNum - 1):kObservationNum], trend[(kObservationNum + 1):src.nrows] + kriging$var1.pred),
"year"=GetPredictionYears(src.years, src.nrows, future))
actual <- data.frame("temperature"=temperature[(kObservationNum - 1):src.nrows],
"year"=GetPredictionYears(src.years, src.nrows, 0))
if (nchar(file_prediction)) {
plot.crossprediction <- ggplot() +
geom_line(data=prediction.kriging, aes(x=year, y=temperature, color="Прогноз Кригинг")) +
geom_line(data=prediction.trend, aes(x=year, y=temperature, color="Прогноз Тренд")) +
geom_line(data=actual, aes(x=year, y=temperature, colour="Актуальное")) +
labs(color="") +
scale_x_continuous(breaks=seq(min(actual$year), max(actual$year) + 5 + future, by=1)) + xlab("Год наблюдения") +
scale_y_continuous(breaks=seq(16, 28, .5)) + ylab("Температура, С") +
theme(axis.text.x = element_text(angle=45, hjust=1)) +
labs(color="")
ggsave(plot=plot.crossprediction, file=file_prediction, width=7, height=4)
}
prediction.kriging$Temperature[3:(src.nrows-kObservationNum)] - actual$Temperature[3:(src.nrows - kObservationNum)] ## what the heck? why 3?
}
src.data.fit <- lm(src$temperature ~ src$year)
src
src.data
src.data.fit
src.data.fit  <- 1
src.data.residuals <- src.data.fit$residuals
src.data.fit <- lm(src.data$temperature ~ src.data$year)
src.data.residuals <- src.data.fit$residuals
src.data.trend <- src.data.fit$fitted.values
cutoff <- trunc(2 * kObservationNum / 3) # let it be "classical" value
#cutoff <- 2
# Make fake second coordinate
kObservationNum <- 32
src.data.fit <- lm(src.data$temperature ~ src.data$year)
src.data.residuals <- src.data.fit$residuals
src.data.trend <- src.data.fit$fitted.values
cutoff <- trunc(2 * kObservationNum / 3) # let it be "classical" value
#cutoff <- 2
# Make fake second coordinate
p <- data.frame("X"=c(1:kObservationNum), "Y"=rep(1, kObservationNum))
# Calculate distances
p.dist<-as.matrix(dist(p[,c("X", "Y")]))
dist.breaks<-quantile(p.dist,seq(.1, .9, by=.1))
coordinates(p) <- ~ X + Y
p.breaks <- (0:cutoff) * 1
hsc <- hscat(src.res[1:kObservationNum]~1, p, breaks=0:20)
hsc <- hscat(src.data.residuals[1:kObservationNum]~1, p, breaks=0:20)
to.pdf(hsc,"figures/12_hscat.pdf", width=7, height=6)
variogram.manual <-  ComputeManualVariogram(src.res[1:kObservationNum], cutoff=cutoff, file=TRUE, file_modeled="figures/14_manual-mod.png")
variogram.manual <-  ComputeManualVariogram(src.data.res[1:kObservationNum], cutoff=cutoff, file=TRUE, file_modeled="figures/14_manual-mod.png")
variogram.manual <-  ComputeManualVariogram(src.data.residuals[1:kObservationNum], cutoff=cutoff, file=TRUE, file_modeled="figures/14_manual-mod.png")
